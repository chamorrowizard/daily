<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Daily Tasking — 24h Health</title>
<meta name="theme-color" content="#6c5ce7" />
<style>
/* =============================
   GLOBAL / THEME
   (inspired by your uploaded file)
   ============================= */
* { box-sizing: border-box; margin: 0; padding: 0; font-family: "Trebuchet MS", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
html,body { height: 100%; }
body {
  background: radial-gradient(ellipse at top left, #11043a 0%, #06021a 40%, #000 100%);
  color: #fff;
  padding: 22px;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* header */
header { display:flex; align-items:center; gap:16px; margin-bottom:18px; }
h1 {
  font-size: 1.8rem;
  text-shadow: 3px 3px 0 #000;
  letter-spacing: 0.3px;
}
.subtitle { opacity: .9; font-size: .92rem; }

/* add area */
#add-area { display:flex; gap:10px; margin: 18px 0 26px; }
#task-name {
  flex: 1; padding: 12px 14px; border-radius: 10px; border: none; font-size: 1rem;
  outline: none;
  background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
  color: #fff;
  box-shadow: inset 0 0 8px rgba(0,0,0,0.6);
}
button.btn {
  padding: 12px 14px; border-radius: 10px; border: none; cursor: pointer; font-weight:700;
  box-shadow: 0 6px 14px rgba(0,0,0,0.6);
}
#add-btn { background: linear-gradient(90deg,#FFF4C2,#FFD700,#CC9A00); color:#000; }
#clear-btn { background: rgba(255,255,255,0.06); color:#fff; }

/* container */
#tasks-container { display:flex; flex-direction:column; gap:18px; max-width:900px; margin:0 auto; }

/* task card */
.task {
  padding: 16px;
  border-radius: 12px;
  position: relative;
  overflow: hidden;
  background: linear-gradient(90deg, rgba(0,0,80,0.6), rgba(38,23,6,0.12));
  box-shadow: 0 8px 30px rgba(0,0,0,0.6);
  border: 1px solid rgba(255,255,255,0.04);
}
.task::before {
  content:""; position:absolute; inset:0; background: gold; opacity:0.06; pointer-events:none; mix-blend-mode:screen;
}
.task-title { font-size:1.15rem; font-weight:800; margin-bottom:10px; }

/* health bar */
.bar-wrapper {
  width:100%; height:28px; background: rgba(255,255,255,0.07); border-radius:14px; overflow:hidden;
  border: 1px solid rgba(255,255,255,0.03);
}
.health-bar {
  height:100%; width:100%;
  transition: width 700ms linear, background 400ms linear;
  box-shadow: inset 0 0 8px rgba(0,0,0,0.6);
}
.meta-row { display:flex; gap:12px; align-items:center; margin-top:10px; font-size:.88rem; opacity:.9; }
.time-left { margin-left: auto; font-weight:700; }

/* buttons row */
.btn-row { display:flex; gap:10px; margin-top:12px; align-items:center; }
.complete-btn { background: linear-gradient(90deg,#32ff4d,#4dff87); color:#000; padding:8px 12px; border-radius:8px; border:none; cursor:pointer; font-weight:700; }
.complete-btn:hover { filter:brightness(1.03); }
.delete-btn { background: linear-gradient(90deg,#ff4d4d,#ff1a1a); color:#fff; padding:8px 12px; border-radius:8px; border:none; cursor:pointer; margin-left:auto; font-weight:700; }

/* small */
.small { font-size:.82rem; opacity:.85; }

/* modal */
.modal-backdrop { position:fixed; inset:0; background: rgba(0,0,0,0.6); display:flex; align-items:center; justify-content:center; z-index:1000; }
.modal { background: linear-gradient(180deg,#0e153a,#07061a); padding:18px; border-radius:10px; width:92%; max-width:420px; box-shadow: 0 12px 40px rgba(0,0,0,0.7); border:1px solid rgba(255,255,255,0.05); color:#fff; }
.modal h3 { margin-bottom:10px; }
.modal p { margin-bottom:14px; opacity:.95; }
.modal .modal-actions { display:flex; gap:10px; justify-content:flex-end; }
.modal .modal-actions button { padding:8px 12px; border-radius:8px; border:none; cursor:pointer; font-weight:700; }
.modal .confirm { background: linear-gradient(90deg,#32ff4d,#4dff87); color:#000; }
.modal .cancel { background: rgba(255,255,255,0.08); color:#fff; }

/* responsive */
@media (max-width:640px) {
  header { flex-direction: column; align-items:flex-start; gap:8px; }
  .time-left { display:none; }
}
</style>
</head>
<body>

<header>
  <div>
    <h1>Daily Tasks</h1>
    <div class="subtitle">Health drains from 100 → 0 over 24 hours. Complete to refill.</div>
  </div>
</header>

<div id="add-area" aria-label="Add task">
  <input id="task-name" type="text" placeholder="New task (press Enter or Add)..." aria-label="Task name" />
  <button id="add-btn" class="btn">Add</button>
  <button id="clear-btn" class="btn" title="Clear all tasks">Clear All</button>
</div>

<main id="tasks-container" aria-live="polite">
  <!-- Task cards rendered here -->
</main>

<!-- Confirmation modal (reused for delete/complete) -->
<div id="modal-root" style="display:none;"></div>

<script>
/*
  Daily Tasking App
  - Health decays linearly over 24 hours (100% → 0%)
  - Complete resets health (lastDone = now)
  - Confirm before completing or deleting
  - Persist to localStorage
  - Render updates every second
  - Based on your uploaded skilldecay.html as reference. (See file used.) :contentReference[oaicite:1]{index=1}
*/

(() => {
  const STORAGE_KEY = "dailyTasks_v1";
  const MS_PER_24H = 24 * 60 * 60 * 1000;

  // app state
  let tasks = JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]");

  // helpers
  function save() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(tasks));
  }

  function now() { return Date.now(); }

  // compute health percentage (0..100) based on lastDone timestamp
  function healthPercent(lastDone) {
    const elapsed = Math.max(0, now() - lastDone);
    const pct = Math.max(0, 100 - (elapsed / MS_PER_24H) * 100);
    return Math.round(pct);
  }

  function timeRemainingMs(lastDone) {
    const elapsed = Math.max(0, now() - lastDone);
    const remaining = Math.max(0, MS_PER_24H - elapsed);
    return remaining;
  }

  function formatTimeLeft(ms) {
    if (ms <= 0) return "Expired";
    const s = Math.floor(ms / 1000);
    const hours = Math.floor(s / 3600);
    const minutes = Math.floor((s % 3600) / 60);
    const seconds = s % 60;
    if (hours > 0) return `${hours}h ${minutes}m`;
    return `${minutes}m ${seconds}s`;
  }

  // DOM refs
  const container = document.getElementById("tasks-container");
  const input = document.getElementById("task-name");
  const addBtn = document.getElementById("add-btn");
  const clearBtn = document.getElementById("clear-btn");
  const modalRoot = document.getElementById("modal-root");

  // Create a confirmation modal, returns a Promise resolving true if confirmed
  function confirmAction({ title = "Confirm", message = "", confirmText = "Yes", cancelText = "Cancel" } = {}) {
    return new Promise(resolve => {
      // build modal
      modalRoot.innerHTML = `
        <div class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="modal-title">
          <div class="modal" role="document">
            <h3 id="modal-title"></h3>
            <p id="modal-msg"></p>
            <div class="modal-actions">
              <button class="cancel" id="modal-cancel">${cancelText}</button>
              <button class="confirm" id="modal-confirm">${confirmText}</button>
            </div>
          </div>
        </div>
      `;
      modalRoot.style.display = "";

      // set text securely
      const titleEl = modalRoot.querySelector("#modal-title");
      const msgEl = modalRoot.querySelector("#modal-msg");
      titleEl.textContent = title;
      msgEl.textContent = message;

      const confirmBtn = modalRoot.querySelector("#modal-confirm");
      const cancelBtn = modalRoot.querySelector("#modal-cancel");

      function cleanup() {
        modalRoot.innerHTML = "";
        modalRoot.style.display = "none";
        confirmBtn.removeEventListener("click", onConfirm);
        cancelBtn.removeEventListener("click", onCancel);
        document.removeEventListener("keydown", onKey);
      }
      function onConfirm() { cleanup(); resolve(true); }
      function onCancel() { cleanup(); resolve(false); }
      function onKey(e) {
        if (e.key === "Escape") { onCancel(); }
        if (e.key === "Enter") { onConfirm(); }
      }

      confirmBtn.addEventListener("click", onConfirm);
      cancelBtn.addEventListener("click", onCancel);
      document.addEventListener("keydown", onKey);
      // focus confirm for keyboard users
      confirmBtn.focus();
    });
  }

  // Add new task
  function addTask(name) {
    if (!name || !name.trim()) return;
    const task = {
      id: Date.now() + Math.floor(Math.random() * 999),
      name: name.trim(),
      lastDone: Date.now()
    };
    tasks.unshift(task); // newest first
    save();
    render(); // immediate render
  }

  // Mark as complete (with confirmation)
  async function completeTask(id) {
    const task = tasks.find(t => t.id === id);
    if (!task) return;
    const ok = await confirmAction({
      title: "Mark task complete?",
      message: `Mark "${task.name}" as done now? This will refill the health bar.`,
      confirmText: "Complete",
      cancelText: "Cancel"
    });
    if (!ok) return;
    task.lastDone = Date.now();
    save();
    render();
  }

  // Delete a task (with confirmation)
  async function deleteTask(id) {
    const task = tasks.find(t => t.id === id);
    if (!task) return;
    const ok = await confirmAction({
      title: "Delete task?",
      message: `Are you sure you want to delete "${task.name}"? This cannot be undone.`,
      confirmText: "Delete",
      cancelText: "Keep"
    });
    if (!ok) return;
    tasks = tasks.filter(t => t.id !== id);
    save();
    render();
  }

  // Clear all tasks (with confirmation)
  async function clearAll() {
    if (tasks.length === 0) return;
    const ok = await confirmAction({
      title: "Clear all tasks?",
      message: `Remove all ${tasks.length} tasks from storage?`,
      confirmText: "Clear All",
      cancelText: "Cancel"
    });
    if (!ok) return;
    tasks = [];
    save();
    render();
  }

  // Build a single task card safely (no innerHTML from user)
  function buildTaskCard(task) {
    const health = healthPercent(task.lastDone);
    let color;
    if (health > 60) color = "linear-gradient(90deg,#32ff4d,#4dff87)";
    else if (health > 30) color = "linear-gradient(90deg,#ffdd00,#ffb300)";
    else color = "linear-gradient(90deg,#ff4d4d,#ff1a1a)";

    const card = document.createElement("div");
    card.className = "task";

    const title = document.createElement("div");
    title.className = "task-title";
    title.textContent = task.name;

    const barWrap = document.createElement("div");
    barWrap.className = "bar-wrapper";

    const bar = document.createElement("div");
    bar.className = "health-bar";
    bar.style.width = health + "%";
    bar.style.background = color;
    bar.setAttribute("aria-valuenow", String(health));
    bar.setAttribute("role", "progressbar");
    bar.setAttribute("aria-label", `${task.name} health`);

    barWrap.appendChild(bar);

    const meta = document.createElement("div");
    meta.className = "meta-row";

    const last = document.createElement("div");
    last.className = "small";
    const readable = new Date(task.lastDone).toLocaleString("en-US", { timeZone: "America/Los_Angeles" });
    last.textContent = `Last completed: ${readable}`;

    const timeLeft = document.createElement("div");
    timeLeft.className = "time-left small";
    timeLeft.textContent = formatTimeLeft(timeRemainingMs(task.lastDone));

    meta.appendChild(last);
    meta.appendChild(timeLeft);

    const btnRow = document.createElement("div");
    btnRow.className = "btn-row";

    const completeBtn = document.createElement("button");
    completeBtn.className = "complete-btn";
    completeBtn.type = "button";
    completeBtn.textContent = "Complete";
    completeBtn.addEventListener("click", () => completeTask(task.id));

    const deleteBtn = document.createElement("button");
    deleteBtn.className = "delete-btn";
    deleteBtn.type = "button";
    deleteBtn.textContent = "Delete";
    deleteBtn.addEventListener("click", () => deleteTask(task.id));

    btnRow.appendChild(completeBtn);
    btnRow.appendChild(deleteBtn);

    card.appendChild(title);
    card.appendChild(barWrap);
    card.appendChild(meta);
    card.appendChild(btnRow);

    // attach for future updates (so we can update width and time-left without re-creating entire DOM)
    card._bar = bar;
    card._timeLeft = timeLeft;
    card._taskId = task.id;

    return card;
  }

  // Render all tasks
  function render() {
    // sort tasks by health ascending (lowest first) to surface tasks needing attention
    const tasksWithHealth = tasks.map(t => ({ ...t, health: healthPercent(t.lastDone) }));
    tasksWithHealth.sort((a,b) => a.health - b.health);

    // Reconcile DOM nodes: simple approach - clear and recreate for clarity & safety
    container.innerHTML = "";
    if (tasksWithHealth.length === 0) {
      const note = document.createElement("div");
      note.className = "small";
      note.style.opacity = ".9";
      note.style.textAlign = "center";
      note.style.padding = "28px";
      note.textContent = "No tasks yet. Add one above to start tracking daily health.";
      container.appendChild(note);
      return;
    }

    tasksWithHealth.forEach(task => {
      const card = buildTaskCard(task);
      container.appendChild(card);
    });
  }

  // Gradual live update: update widths & timers without rebuilding everything every second
  function liveUpdate() {
    const cards = Array.from(container.children);
    if (cards.length === 0) return;
    cards.forEach(card => {
      const id = card._taskId;
      if (!id) return;
      const task = tasks.find(t => t.id === id);
      if (!task) return;
      const hp = healthPercent(task.lastDone);
      const remainingMs = timeRemainingMs(task.lastDone);
      // update bar & time text if changed
      if (card._bar) card._bar.style.width = hp + "%";
      if (card._bar) {
        let color;
        if (hp > 60) color = "linear-gradient(90deg,#32ff4d,#4dff87)";
        else if (hp > 30) color = "linear-gradient(90deg,#ffdd00,#ffb300)";
        else color = "linear-gradient(90deg,#ff4d4d,#ff1a1a)";
        card._bar.style.background = color;
      }
      if (card._timeLeft) card._timeLeft.textContent = formatTimeLeft(remainingMs);
    });
  }

  // wire up add button & enter key
  addBtn.addEventListener("click", () => {
    addTask(input.value);
    input.value = "";
    input.focus();
  });

  input.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      addTask(input.value);
      input.value = "";
    }
  });

  clearBtn.addEventListener("click", clearAll);

  // initialize render
  render();

  // update every second for smooth countdown
  setInterval(liveUpdate, 1000);

  // occasionally re-render full list to ensure ordering remains correct (every 10s)
  setInterval(render, 10000);

  // expose small debugging helpers on window (optional)
  window.dailyTasks = {
    get: () => tasks,
    add: (name) => { addTask(name); },
    clear: () => { tasks = []; save(); render(); }
  };
})();
</script>

</body>
</html>
